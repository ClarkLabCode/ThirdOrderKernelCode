function ExtractTraceFromPower(powerSpectrum)
    % the goal of this function is to extract a real function which
    % generates the supplied powerspectrum. Since the same powerspectrum
    % can be generated by an infinite number of functions, I minimize the
    % L1 norm

    [sizeY,sizeX] = size(powerSpectrum);
    
    if ~(mod(sizeY,2)==1 && mod(sizeX,2)==1)
        error('the size of the powerspectrum should be odd');
    end
    
    %% go from power to amplitude
    fftZeroPhase = sqrt(powerSpectrum);
    
    %% Start with random phase
    % all phase information is contained in the top half of the 2d fft
    topHalfPhase = 2*pi*rand(floor(sizeY/2),sizeX);
    zeroTemporalFrequencyPhase = 2*pi*rand(1,floor(sizeX/2));
    phaseIn = [reshape(zeroTemporalFrequencyPhase,[numel(zeroTemporalFrequencyPhase) 1]); reshape(topHalfPhase,[numel(topHalfPhase) 1])];
    
    lowerBound = zeros(size(phaseIn));
    upperBound = zeros(size(phaseIn))+2*pi;
    
    objFun = @(x)L1Objective(x,fftZeroPhase);
    
    fitPhase = fmincon(objFun,phaseIn,[],[],[],[],lowerBound,upperBound);
%     fitPhase = fminsearch(objFun,phaseIn);

    %% use the fit phase to generate the function
    [sizeY,sizeX] = size(fftZeroPhase);
    zeroFrequencyInd = floor(sizeX/2);
    zeroTemporalFrequencyPhase = [fitPhase(1:zeroFrequencyInd); 0; -fitPhase(zeroFrequencyInd:-1:1)];
    zeroTemporalFrequencyPhase = reshape(zeroTemporalFrequencyPhase,[1 numel(zeroTemporalFrequencyPhase)]);
    topHalfPhase = reshape(fitPhase(zeroFrequencyInd+1:end),floor(sizeY/2),sizeX);
    bottomHalfPhase = -rot90(topHalfPhase(1:floor(sizeY/2),:),2);
    phaseMat = [topHalfPhase; zeroTemporalFrequencyPhase; bottomHalfPhase];
    phaseMat = ifftshift(phaseMat);
    
    phaseShift = exp(1i*phaseMat);
    fourierWithPhase = fftZeroPhase.*phaseShift;
    functionEst = ifft2(fourierWithPhase);
    
    MakeFigure;
    imagesc(functionEst);
    caxis([-abs(max(functionEst(:))) abs(max(functionEst(:)))]);
    colorbar;
end

function l1Loss = L1Objective(phaseIn,fftZeroPhase)
    % construct the phase matrix from the phase information in the top half
    % of the function. Since the function is real this represents all the
    % phase information
    [sizeY,sizeX] = size(fftZeroPhase);
    zeroFrequencyInd = floor(sizeX/2);
    zeroTemporalFrequencyPhase = [phaseIn(1:zeroFrequencyInd); 0; -phaseIn(zeroFrequencyInd:-1:1)];
    zeroTemporalFrequencyPhase = reshape(zeroTemporalFrequencyPhase,[1 numel(zeroTemporalFrequencyPhase)]);
    topHalfPhase = reshape(phaseIn(zeroFrequencyInd+1:end),floor(sizeY/2),sizeX);
    bottomHalfPhase = -rot90(topHalfPhase(1:floor(sizeY/2),:),2);
    phaseMat = [topHalfPhase; zeroTemporalFrequencyPhase; bottomHalfPhase];
    phaseMat = ifftshift(phaseMat);
    
    phaseShift = exp(1i*phaseMat);
    fourierWithPhase = fftZeroPhase.*phaseShift;
    functionEst = ifft2(fourierWithPhase);
    l1Loss = 1/sum(abs(reshape(functionEst,[numel(functionEst) 1])).^4);
end